
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Channel Projection Corollary - Complete Farey Hierarchy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #000000;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 2560px;
            margin: 0 auto;
            padding: 15px;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #333;
        }
        
        h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
            color: #ffffff;
        }
        
        .subtitle {
            font-size: 1.1em;
            color: #aaa;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 15px;
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .controls {
            background: #111111;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .control-section {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .section-title {
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        label {
            font-weight: 600;
            font-size: 0.85em;
            color: #cccccc;
        }
        
        input[type="number"], select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222222;
            color: #ffffff;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .button-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 14px;
            border: none;
            border-radius: 4px;
            background: linear-gradient(135deg, #00ffff 0%, #0088ff 100%);
            color: #000;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.4);
        }
        
        button.preset-btn {
            background: linear-gradient(135deg, #666 0%, #888 100%);
            color: #fff;
            padding: 6px 12px;
            font-size: 0.8em;
        }
        
        .canvas-container {
            background: #000000;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #333;
            position: relative;
            min-height: 700px;
        }
        
        canvas {
            border: 2px solid #333333;
            border-radius: 4px;
            background: #000000;
            cursor: crosshair;
            max-width: 100%;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .info-box {
            background: #111111;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .info-box h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .stat-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #333;
        }
        
        .stat-label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 6px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            max-width: 350px;
            font-size: 0.85em;
            line-height: 1.5;
            border: 1px solid #00ffff;
        }
        
        .legend {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid white;
            flex-shrink: 0;
        }
        
        .slider-value {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            color: #00ffff;
            font-weight: bold;
        }
        
        .analysis-text {
            font-size: 0.85em;
            line-height: 1.6;
            color: #ccc;
        }
        
        .analysis-text strong {
            color: #00ffff;
        }
        
        .click-info {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            border-left: 3px solid #00ffff;
            font-size: 0.85em;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Modular Rings & Farey Hierarchy</h1>
            <div class="subtitle">Visualizing reduction paths: Primes (Fermat's Little Theorem) have only gcd=1 | Composites reduce through Farey channels</div>
        </header>
        
        <div class="main-layout">
            <div class="left-panel">
                <div class="controls">
                    <div class="control-section">
                        <div class="section-title">Modulus Selection</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label>Modulus (M): <span class="slider-value" id="modulusValue">12</span></label>
                                <input type="range" id="modulusSlider" min="4" max="200" value="12">
                            </div>
                            <div class="control-group">
                                <label for="modulusInput">Custom Input:</label>
                                <input type="number" id="modulusInput" min="2" max="500" value="12">
                            </div>
                        </div>
                        <div class="button-group" style="margin-top: 8px;">
                            <button class="preset-btn" onclick="setModulus(5)">M=5 (prime)</button>
                            <button class="preset-btn" onclick="setModulus(7)">M=7 (prime)</button>
                            <button class="preset-btn" onclick="setModulus(11)">M=11 (prime)</button>
                            <button class="preset-btn" onclick="setModulus(13)">M=13 (prime)</button>
                            <button class="preset-btn" onclick="setModulus(6)">M=6</button>
                            <button class="preset-btn" onclick="setModulus(12)">M=12</button>
                            <button class="preset-btn" onclick="setModulus(24)">M=24</button>
                            <button class="preset-btn" onclick="setModulus(30)">M=30</button>
                            <button class="preset-btn" onclick="setModulus(60)">M=60</button>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">View Mode</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label for="viewMode">Projection:</label>
                                <select id="viewMode">
                                    <option value="2d">2D Circular</option>
                                    <option value="3d">3D Chandelier</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-section" id="view3DControls" style="display: none;">
                        <div class="section-title">3D Camera</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label>Camera Distance: <span class="slider-value" id="cameraDistValue">3.5</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="cameraDist" min="20" max="80" value="35" style="flex: 1;">
                                    <input type="number" id="cameraDistInput" min="2" max="8" step="0.1" value="3.5" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Vertical Spacing: <span class="slider-value" id="vertSpacingValue">0.8</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="vertSpacing" min="20" max="200" value="80" style="flex: 1;">
                                    <input type="number" id="vertSpacingInput" min="0.2" max="2" step="0.1" value="0.8" style="width: 60px;">
                                </div>
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 8px;">
                            <div class="control-group">
                                <label>X-Axis Tilt: <span class="slider-value" id="rotXValue">20°</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="rotX" min="-90" max="90" value="20" style="flex: 1;">
                                    <input type="number" id="rotXInput" min="-90" max="90" value="20" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Y-Axis Spin: <span class="slider-value" id="rotYValue">0°</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="rotY" min="0" max="360" value="0" style="flex: 1;">
                                    <input type="number" id="rotYInput" min="0" max="360" value="0" style="width: 60px;">
                                </div>
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 8px;">
                            <div class="control-group">
                                <label>Z-Axis Roll: <span class="slider-value" id="rotZValue">0°</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="rotZ" min="-90" max="90" value="0" style="flex: 1;">
                                    <input type="number" id="rotZInput" min="-90" max="90" value="0" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Perspective: <span class="slider-value" id="perspectiveValue">800</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="perspective" min="400" max="2000" value="800" style="flex: 1;">
                                    <input type="number" id="perspectiveInput" min="400" max="2000" value="800" style="width: 60px;">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">Visual Controls</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label>Point Size: <span class="slider-value" id="pointSizeValue">5</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="pointSize" min="1" max="20" value="5" style="flex: 1;">
                                    <input type="number" id="pointSizeInput" min="1" max="20" value="5" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Farey Line Width: <span class="slider-value" id="lineWidthValue">1.5</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="fareyLineWidth" min="5" max="50" value="15" style="flex: 1;">
                                    <input type="number" id="fareyLineWidthInput" min="0.5" max="5" step="0.1" value="1.5" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Farey Line Opacity: <span class="slider-value" id="opacityValue">0.20</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="fareyOpacity" min="5" max="100" value="20" style="flex: 1;">
                                    <input type="number" id="fareyOpacityInput" min="0.05" max="1" step="0.01" value="0.20" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Ring Spacing: <span class="slider-value" id="spacingValue">1.0</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="ringSpacing" min="50" max="200" value="100" style="flex: 1;">
                                    <input type="number" id="ringSpacingInput" min="0.5" max="2" step="0.1" value="1.0" style="width: 60px;">
                                </div>
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 8px;">
                            <div class="control-group">
                                <label>Global Rotation: <span class="slider-value" id="rotationValue">0°</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="rotation" min="0" max="360" value="0" style="flex: 1;">
                                    <input type="number" id="rotationInput" min="0" max="360" value="0" style="width: 60px;">
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Ring Differential: <span class="slider-value" id="ringRotationValue">0°</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="ringRotation" min="0" max="720" value="0" style="flex: 1;">
                                    <input type="number" id="ringRotationInput" min="0" max="720" value="0" style="width: 60px;">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">Display Filters</div>
                        <div class="control-grid">
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="showFareyLines" checked>
                                <label for="showFareyLines">Farey Lines</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="showZeroConnections" checked>
                                <label for="showZeroConnections">r=0 Connections (Red)</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="showCoprimes" checked>
                                <label for="showCoprimes">Show gcd=1 Points</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="showReducibles" checked>
                                <label for="showReducibles">Show gcd>1 Points</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="showLabels" checked>
                                <label for="showLabels">Ring Labels (M')</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="showAllRings" checked>
                                <label for="showAllRings">All Rings</label>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">Point Labels</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label for="labelMode">Label Points By:</label>
                                <select id="labelMode">
                                    <option value="none">None</option>
                                    <option value="farey">Farey (r/M)</option>
                                    <option value="theta">Angle (θ)</option>
                                    <option value="gcd">GCD Value</option>
                                    <option value="r">Residue (r)</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="labelFilter">Show Labels For:</label>
                                <select id="labelFilter">
                                    <option value="all">All Points</option>
                                    <option value="outer">Outer Ring Only</option>
                                    <option value="coprime">Coprime Only</option>
                                    <option value="reducible">Reducible Only</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">Color Scheme</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label for="colorScheme">Color Points By:</label>
                                <select id="colorScheme">
                                    <option value="coprime">Coprime vs Reducible</option>
                                    <option value="gcd">GCD Value</option>
                                    <option value="gcd_rainbow">GCD Rainbow</option>
                                    <option value="ring">By Ring (M')</option>
                                    <option value="depth">Channel Depth (M')</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="coprimeColor">Coprime Color (gcd=1):</label>
                                <input type="color" id="coprimeColor" value="#00ffff">
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 8px;">
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="animateRotation">
                                <label for="animateRotation">Animate Rotation</label>
                            </div>
                            <div class="control-group">
                                <label>Speed: <span class="slider-value" id="animSpeedValue">1.0x</span></label>
                                <div style="display: flex; gap: 5px;">
                                    <input type="range" id="animSpeed" min="10" max="300" value="100" style="flex: 1;">
                                    <input type="number" id="animSpeedInput" min="0.1" max="3" step="0.1" value="1.0" style="width: 60px;">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">Export & Actions</div>
                        <div class="button-group">
                            <button onclick="updateVisualization()">Update Visualization</button>
                        </div>
                    </div>
                    
                    <div class="control-section">
                        <div class="section-title">Export Configuration</div>
                        <div class="control-grid">
                            <div class="control-group">
                                <label for="exportTitle">Export Title:</label>
                                <input type="text" id="exportTitle" value="Modular Rings & Farey Hierarchy">
                            </div>
                            <div class="control-group">
                                <label for="exportSubtitle">Subtitle (optional):</label>
                                <input type="text" id="exportSubtitle" placeholder="Custom subtitle...">
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 8px;">
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowLegend" checked>
                                <label for="exportShowLegend">Include Legend Panel</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowStats" checked>
                                <label for="exportShowStats">Statistics</label>
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 4px;">
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowFactorization" checked>
                                <label for="exportShowFactorization">Prime Factorization</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowDivisors" checked>
                                <label for="exportShowDivisors">Divisor List</label>
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 4px;">
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowRingInfo" checked>
                                <label for="exportShowRingInfo">Ring Structure</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowColorKey" checked>
                                <label for="exportShowColorKey">Color Key</label>
                            </div>
                        </div>
                        <div class="control-grid" style="margin-top: 4px;">
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowSettings" checked>
                                <label for="exportShowSettings">Current Settings</label>
                            </div>
                            <div class="control-group checkbox-group">
                                <input type="checkbox" id="exportShowTimestamp" checked>
                                <label for="exportShowTimestamp">Timestamp</label>
                            </div>
                        </div>
                        <div class="button-group" style="margin-top: 8px;">
                            <button onclick="exportPNG('standard')" style="background: linear-gradient(135deg, #607D8B 0%, #455A64 100%);">Standard (1920×1080)</button>
                            <button onclick="exportPNG('2K')" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">2K (2560×1440)</button>
                        </div>
                        <div class="button-group" style="margin-top: 4px;">
                            <button onclick="exportPNG('4K')" style="background: linear-gradient(135deg, #2196F3 0%, #0b7dda 100%);">4K (3840×2160)</button>
                            <button onclick="exportPNG('8K')" style="background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);">8K (7680×4320)</button>
                        </div>
                        <div class="button-group" style="margin-top: 4px;">
                            <button onclick="exportCSV()" style="background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);">Export CSV Data</button>
                        </div>
                    </div>
                </div>
                
                <div class="canvas-container">
                    <canvas id="mainCanvas" width="1400" height="1400"></canvas>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="info-box">
                    <h3>Configuration</h3>
                    <div class="analysis-text">
                        <strong>Modulus M = <span id="configM">12</span></strong><br>
                        <span id="configFactors">2² × 3</span><br>
                        <span id="configDivisors">Divisors: 1, 2, 3, 4, 6, 12</span>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Rings Shown</div>
                            <div class="stat-value" id="statRings">6</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Points</div>
                            <div class="stat-value" id="statPoints">28</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">φ(M)</div>
                            <div class="stat-value" id="statPhi">4</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Farey Channels</div>
                            <div class="stat-value" id="statChannels">5</div>
                        </div>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Understanding the Visualization</h3>
                    <div class="analysis-text">
                        <strong>View Modes:</strong><br>
                        • 2D Circular: Traditional flat view<br>
                        • 3D Chandelier: Stacked rings (M at top, M'=1 at bottom)<br><br>
                        
                        <strong>Circle Convention:</strong><br>
                        • r=0 is at 3 o'clock (θ=0)<br>
                        • Points at angle θ = 2πr/M<br>
                        • Counter-clockwise from right<br><br>
                        
                        <strong>3D Chandelier Mode:</strong><br>
                        • Drag to rotate view<br>
                        • Scroll to zoom in/out<br>
                        • Red chains: r=0 → center bottom<br>
                        • Gold chains: Farey reductions<br>
                        • Rings descend from M (top) to M'=1 (bottom)<br><br>
                        
                        <strong>Ring Differential Rotation:</strong><br>
                        • 0°: All rings aligned<br>
                        • Small (10-45°): Gentle spiral<br>
                        • Medium (90°): Helical twist<br>
                        • 360°: Each ring rotated one full turn more<br>
                        • Reveals hidden symmetries & patterns<br><br>
                        
                        <strong>For Prime M (Fermat's Little Theorem):</strong><br>
                        • Only 2 rings: M (outer) and 1 (center)<br>
                        • All r∈{1,2,...,p-1} have gcd=1 (cyan)<br>
                        • Only r=0 is reducible: 0/p → 0/1<br>
                        • Single Farey line from r=0 to center<br>
                        • Demonstrates: a^(p-1) ≡ 1 (mod p)<br><br>
                        
                        <strong>For Composite M (Farey Channels):</strong><br>
                        • Multiple rings for each divisor<br>
                        • Each reducible r/M connects to r'/M'<br>
                        • Shows complete reduction cascade<br><br>
                        
                        <strong>Example M=12, r=8:</strong><br>
                        8/12 → 2/3 (gcd=4, M'=3)<br>
                        Line connects position 8 on M=12 to position 2 on M'=3.
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Ring Structure</h3>
                    <div id="ringInfo" class="analysis-text">
                        Click Update to see ring details...
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Color Key</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffd700;"></div>
                            <span>Gold = Farey connection lines</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00ffff;"></div>
                            <span>Cyan = Coprime points</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff0066;"></div>
                            <span>Red = Reducible points</span>
                        </div>
                    </div>
                </div>
                
                <div class="info-box">
                    <h3>Click Interaction</h3>
                    <div class="click-info" id="clickInfo">
                        Click any point to see its complete reduction path through all Farey channels...
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        let currentData = null;
        let animationFrame = null;
        
        // 3D Camera state
        let camera = {
            distance: 3.5,
            rotX: 20,
            rotY: 0,
            rotZ: 0,
            perspective: 800
        };
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // 3D projection function
        function project3D(x, y, z) {
            const rotXRad = camera.rotX * Math.PI / 180;
            const rotYRad = camera.rotY * Math.PI / 180;
            const rotZRad = camera.rotZ * Math.PI / 180;
            
            // Rotate X
            let y1 = y * Math.cos(rotXRad) - z * Math.sin(rotXRad);
            let z1 = y * Math.sin(rotXRad) + z * Math.cos(rotXRad);
            
            // Rotate Y
            let x2 = x * Math.cos(rotYRad) + z1 * Math.sin(rotYRad);
            let z2 = -x * Math.sin(rotYRad) + z1 * Math.cos(rotYRad);
            
            // Rotate Z
            let x3 = x2 * Math.cos(rotZRad) - y1 * Math.sin(rotZRad);
            let y3 = x2 * Math.sin(rotZRad) + y1 * Math.cos(rotZRad);
            
            // Apply camera distance
            z2 += camera.distance;
            
            // Perspective projection
            const scale = camera.perspective / (camera.perspective + z2);
            
            return {
                x: x3 * scale + canvas.width / 2,
                y: y3 * scale + canvas.height / 2,
                z: z2,
                scale: scale
            };
        }
        
        function gcd(a, b) {
            while (b !== 0) [a, b] = [b, a % b];
            return a;
        }
        
        function eulerPhi(n) {
            let result = n, p = 2, temp = n;
            while (p * p <= temp) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
                p++;
            }
            if (temp > 1) result -= result / temp;
            return Math.floor(result);
        }
        
        function primeFactorization(n) {
            const factors = {};
            let temp = n;
            for (let i = 2; i * i <= temp; i++) {
                while (temp % i === 0) {
                    factors[i] = (factors[i] || 0) + 1;
                    temp /= i;
                }
            }
            if (temp > 1) factors[temp] = 1;
            return Object.entries(factors).map(([p, e]) => e > 1 ? `${p}^${e}` : p).join(' × ') || n.toString();
        }
        
        function getDivisors(n) {
            const divisors = [];
            for (let i = 1; i <= n; i++) {
                if (n % i === 0) divisors.push(i);
            }
            return divisors;
        }
        
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }
        
        function lowestTerms(r, m) {
            if (r === 0) return [0, 1];
            const d = gcd(r, m);
            return [r / d, m / d];
        }
        
        function computeData(M) {
            const divisors = getDivisors(M);
            const data = {
                M: M,
                isPrime: isPrime(M),
                divisors: divisors,
                phi: eulerPhi(M),
                factorization: primeFactorization(M),
                rings: new Map(), // Map from M' to array of points
                allPoints: []
            };
            
            // For each divisor (modulus), create its complete residue system
            divisors.forEach(m => {
                const ring = [];
                for (let r = 0; r < m; r++) {
                    const d = gcd(r, m);
                    const [rRed, mRed] = lowestTerms(r, m);
                    
                    const pt = {
                        r: r,
                        M: m,
                        d: d,
                        rRed: rRed,
                        mRed: mRed,
                        isIrreducible: (d === 1 || r === 0),
                        theta: (2 * Math.PI * r) / m // Standard: r=0 at θ=0 (3 o'clock)
                    };
                    
                    ring.push(pt);
                    data.allPoints.push(pt);
                }
                data.rings.set(m, ring);
            });
            
            return data;
        }
        
        function getColorForPoint(pt, scheme) {
            const coprimeColor = document.getElementById('coprimeColor').value;
            
            if (scheme === 'coprime') {
                if (pt.r === 0) return '#888888';
                return pt.isIrreducible ? coprimeColor : '#ff0066';
            } else if (scheme === 'gcd') {
                if (pt.r === 0) return '#888888';
                const hue = (pt.d * 60) % 360;
                return `hsl(${hue}, 100%, 50%)`;
            } else if (scheme === 'gcd_rainbow') {
                if (pt.r === 0) return '#888888';
                const hue = (pt.d * 137.5) % 360; // Golden angle for better distribution
                return `hsl(${hue}, 90%, 60%)`;
            } else if (scheme === 'ring') {
                const hue = (pt.M * 60) % 360;
                return `hsl(${hue}, 80%, 60%)`;
            } else if (scheme === 'depth') {
                const hue = (pt.mRed * 137.5) % 360;
                return `hsl(${hue}, 100%, 50%)`;
            }
            return '#ffffff';
        }
        
        function drawVisualization() {
            if (!currentData) return;
            
            const viewMode = document.getElementById('viewMode').value;
            
            if (viewMode === '3d') {
                draw3DVisualization();
            } else {
                draw2DVisualization();
            }
        }
        
        function draw3DVisualization() {
            if (!currentData) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const vertSpacing = parseFloat(document.getElementById('vertSpacing').value) / 100;
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const fareyOpacity = parseFloat(document.getElementById('fareyOpacity').value) / 100;
            const fareyLineWidth = parseFloat(document.getElementById('fareyLineWidth').value) / 10;
            const showFarey = document.getElementById('showFareyLines').checked;
            const showZeroConn = document.getElementById('showZeroConnections').checked;
            const showCoprimes = document.getElementById('showCoprimes').checked;
            const showReducibles = document.getElementById('showReducibles').checked;
            const showAllRings = document.getElementById('showAllRings').checked;
            const colorScheme = document.getElementById('colorScheme').value;
            
            const numLevels = currentData.divisors.length;
            const baseSize = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Calculate 3D positions for all points
            const points3D = [];
            currentData.divisors.forEach((m, levelIndex) => {
                const ring = currentData.rings.get(m);
                const radius = (m / currentData.M) * baseSize / camera.perspective;
                const height = (levelIndex / (numLevels - 1)) * 2 * vertSpacing;
                
                ring.forEach(pt => {
                    points3D.push({
                        pt: pt,
                        x: radius * Math.cos(pt.theta),
                        y: height,
                        z: radius * Math.sin(pt.theta),
                        radius: radius,
                        level: levelIndex
                    });
                });
            });
            
            // Project to 2D
            const projected = points3D.map(p3d => ({
                ...p3d,
                proj: project3D(p3d.x, p3d.y, p3d.z)
            }));
            
            // Sort by depth for proper occlusion
            projected.sort((a, b) => b.proj.z - a.proj.z);
            
            // Draw ring circles
            if (showAllRings) {
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = '#444444';
                ctx.lineWidth = 1;
                
                currentData.divisors.forEach((m, levelIndex) => {
                    const radius = (m / currentData.M) * baseSize / camera.perspective;
                    const height = (levelIndex / (numLevels - 1)) * 2 * vertSpacing;
                    
                    const segments = 64;
                    ctx.beginPath();
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const z = radius * Math.sin(angle);
                        const p = project3D(x, height, z);
                        if (i === 0) ctx.moveTo(p.x, p.y);
                        else ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw r=0 red chains to center bottom
            if (showZeroConn) {
                ctx.globalAlpha = fareyOpacity * 1.2;
                ctx.lineWidth = fareyLineWidth * 1.5;
                ctx.strokeStyle = '#ff0000';
                
                const centerBottom = project3D(0, 0, 0);
                
                projected.forEach(p => {
                    if (p.pt.r === 0 && p.pt.M > 1) {
                        ctx.beginPath();
                        ctx.moveTo(p.proj.x, p.proj.y);
                        ctx.lineTo(centerBottom.x, centerBottom.y);
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw Farey chains
            if (showFarey) {
                ctx.globalAlpha = fareyOpacity;
                ctx.lineWidth = fareyLineWidth;
                ctx.strokeStyle = '#ffd700';
                
                projected.forEach(p => {
                    if (p.pt.r === 0 || p.pt.mRed === 1) return;
                    
                    const target = projected.find(t => 
                        t.pt.M === p.pt.mRed && t.pt.r === p.pt.rRed
                    );
                    
                    if (target && target.proj.z < camera.distance + 5) {
                        ctx.beginPath();
                        ctx.moveTo(p.proj.x, p.proj.y);
                        ctx.lineTo(target.proj.x, target.proj.y);
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw points
            projected.forEach(p => {
                // Apply filters
                if (!showCoprimes && p.pt.isIrreducible && p.pt.r !== 0) return;
                if (!showReducibles && !p.pt.isIrreducible && p.pt.r !== 0) return;
                
                const color = getColorForPoint(p.pt, colorScheme);
                const size = pointSize * p.proj.scale;
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.proj.x, p.proj.y, size, 0, 2 * Math.PI);
                ctx.fill();
                
                if (p.pt.r === 0) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            // 3D info overlay
            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('3D CHANDELIER MODE', 20, canvas.height - 60);
            ctx.font = '12px monospace';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillText('Drag to rotate | Scroll to zoom', 20, canvas.height - 40);
            ctx.fillText(`M=${currentData.M} | ${currentData.divisors.length} levels | Top→Bottom`, 20, canvas.height - 20);
        }
        
        function draw2DVisualization() {
            if (!currentData) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.42;
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const fareyOpacity = parseFloat(document.getElementById('fareyOpacity').value) / 100;
            const fareyLineWidth = parseFloat(document.getElementById('fareyLineWidth').value) / 10;
            const spacing = parseFloat(document.getElementById('ringSpacing').value) / 100;
            const globalRotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            const ringRotation = parseFloat(document.getElementById('ringRotation').value) * Math.PI / 180;
            const showFarey = document.getElementById('showFareyLines').checked;
            const showZeroConn = document.getElementById('showZeroConnections').checked;
            const showCoprimes = document.getElementById('showCoprimes').checked;
            const showReducibles = document.getElementById('showReducibles').checked;
            const showLabels = document.getElementById('showLabels').checked;
            const showAllRings = document.getElementById('showAllRings').checked;
            const colorScheme = document.getElementById('colorScheme').value;
            const labelMode = document.getElementById('labelMode').value;
            const labelFilter = document.getElementById('labelFilter').value;
            
            // Calculate radius for each ring and assign ring index
            const divisors = currentData.divisors.slice().reverse(); // Largest first (outer to inner)
            const radiusMap = new Map();
            const ringIndexMap = new Map(); // 0 for innermost (M'=1), increasing outward
            
            divisors.forEach((m, idx) => {
                radiusMap.set(m, baseRadius * Math.pow(0.85, idx * spacing));
                ringIndexMap.set(m, divisors.length - 1 - idx); // Reverse: 0 for M'=1, max for M
            });
            
            // angle(k, m, ringIndex) = (2π × k/m) + globalPhase + (rotationAmount × ringIndex)
            function getAngle(r, m) {
                const ringIndex = ringIndexMap.get(m);
                return (2 * Math.PI * r) / m + globalRotation + (ringRotation * ringIndex);
            }
            
            // Draw r=0 connections in RED (to M'=1 center)
            if (showZeroConn) {
                ctx.globalAlpha = fareyOpacity * 1.2;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = fareyLineWidth * 1.5;
                
                divisors.slice(0, -1).forEach(m => {
                    const ring = currentData.rings.get(m);
                    const outerR = radiusMap.get(m);
                    const centerR = radiusMap.get(1) || 0;
                    
                    ring.forEach(pt => {
                        if (pt.r !== 0) return; // Only r=0 points
                        
                        const sourceTheta = getAngle(pt.r, pt.M);
                        const targetTheta = getAngle(0, 1);
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            centerX + outerR * Math.cos(sourceTheta),
                            centerY + outerR * Math.sin(sourceTheta)
                        );
                        ctx.lineTo(centerX, centerY); // To center
                        ctx.stroke();
                    });
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw Farey lines (non-zero reducible connections)
            if (showFarey) {
                ctx.globalAlpha = fareyOpacity;
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = fareyLineWidth;
                
                // For each ring except M'=1
                divisors.slice(0, -1).forEach(m => {
                    const ring = currentData.rings.get(m);
                    const outerR = radiusMap.get(m);
                    
                    ring.forEach(pt => {
                        if (pt.r === 0 || pt.mRed === 1) return; // Skip r=0 (drawn separately) and already reduced
                        
                        // Find target ring and position
                        const innerR = radiusMap.get(pt.mRed);
                        const targetTheta = getAngle(pt.rRed, pt.mRed);
                        const sourceTheta = getAngle(pt.r, pt.M);
                        
                        // Draw curved line
                        ctx.beginPath();
                        ctx.moveTo(
                            centerX + outerR * Math.cos(sourceTheta),
                            centerY + outerR * Math.sin(sourceTheta)
                        );
                        
                        // Quadratic curve
                        const midR = (outerR + innerR) / 2;
                        const midTheta = (sourceTheta + targetTheta) / 2;
                        ctx.quadraticCurveTo(
                            centerX + midR * 0.95 * Math.cos(midTheta),
                            centerY + midR * 0.95 * Math.sin(midTheta),
                            centerX + innerR * Math.cos(targetTheta),
                            centerY + innerR * Math.sin(targetTheta)
                        );
                        ctx.stroke();
                    });
                });
                ctx.globalAlpha = 1.0;
            }
            
            // Draw rings
            divisors.forEach(m => {
                if (!showAllRings && m !== currentData.M && m !== 1) return;
                
                const r = radiusMap.get(m);
                ctx.strokeStyle = m === currentData.M ? 'rgba(255, 255, 255, 0.6)' : 
                                  m === 1 ? 'rgba(255, 215, 0, 0.4)' : 
                                  'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = m === currentData.M ? 2 : 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Label
                if (showLabels) {
                    ctx.fillStyle = m === currentData.M ? '#ffffff' : '#ffd700';
                    ctx.font = m === currentData.M ? 'bold 12px monospace' : '11px monospace';
                    ctx.textAlign = 'left';
                    const labelAngle = getAngle(0, m);
                    const labelDist = r + 8;
                    ctx.fillText(`M=${m}`, centerX + labelDist * Math.cos(labelAngle), 
                                          centerY + labelDist * Math.sin(labelAngle));
                }
            });
            
            // Draw points
            divisors.forEach(m => {
                if (!showAllRings && m !== currentData.M && m !== 1) return;
                
                const ring = currentData.rings.get(m);
                const radius = radiusMap.get(m);
                
                ring.forEach(pt => {
                    // Apply filters
                    if (!showCoprimes && pt.isIrreducible && pt.r !== 0) return;
                    if (!showReducibles && !pt.isIrreducible && pt.r !== 0) return;
                    
                    const angle = getAngle(pt.r, pt.M);
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    const color = getColorForPoint(pt, colorScheme);
                    let size = pt.r === 0 ? pointSize * 1.2 : pointSize;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.strokeStyle = pt.r === 0 ? '#ffff00' : 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = pt.r === 0 ? 2 : 1;
                    ctx.stroke();
                    
                    // Point labels
                    if (labelMode !== 'none') {
                        let showLabel = false;
                        if (labelFilter === 'all') showLabel = true;
                        else if (labelFilter === 'outer' && m === currentData.M) showLabel = true;
                        else if (labelFilter === 'coprime' && pt.isIrreducible) showLabel = true;
                        else if (labelFilter === 'reducible' && !pt.isIrreducible) showLabel = true;
                        
                        if (showLabel && currentData.M <= 50) { // Only label for smaller moduli
                            ctx.fillStyle = color;
                            ctx.font = 'bold 9px monospace';
                            ctx.textAlign = 'center';
                            
                            let label = '';
                            if (labelMode === 'farey') label = `${pt.r}/${pt.M}`;
                            else if (labelMode === 'theta') label = `${(pt.theta * 180 / Math.PI).toFixed(0)}°`;
                            else if (labelMode === 'gcd') label = `gcd=${pt.d}`;
                            else if (labelMode === 'r') label = `${pt.r}`;
                            
                            ctx.fillText(label, x, y - size - 3);
                        }
                    }
                    
                    // Special r=0 label
                    if (pt.r === 0 && m === currentData.M && labelMode === 'none') {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 10px monospace';
                        ctx.textAlign = 'left';
                        ctx.fillText('r=0', x + size + 5, y + 4);
                        ctx.fillText('θ=0', x + size + 5, y + 14);
                    }
                });
            });
            
            // Center text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`M = ${currentData.M}`, centerX, centerY - 25);
            
            ctx.fillStyle = currentData.isPrime ? '#00ff00' : '#ff8800';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText(currentData.isPrime ? 'PRIME' : 'COMPOSITE', centerX, centerY - 5);
            
            ctx.fillStyle = 'white';
            ctx.font = '14px sans-serif';
            ctx.fillText(`${divisors.length} rings`, centerX, centerY + 15);
            ctx.fillText(`θ = 2πr/M`, centerX, centerY + 30);
        }
        
        function updateVisualization() {
            let M = parseInt(document.getElementById('modulusInput').value);
            if (M < 2) M = 2;
            
            document.getElementById('modulusInput').value = M;
            document.getElementById('modulusSlider').value = Math.min(M, 200);
            document.getElementById('modulusValue').textContent = M;
            
            currentData = computeData(M);
            
            // Update stats
            document.getElementById('configM').textContent = M;
            document.getElementById('configFactors').textContent = currentData.isPrime ? 
                `PRIME (only divisors: 1, ${M})` : currentData.factorization;
            document.getElementById('configDivisors').textContent = 'Divisors: ' + currentData.divisors.join(', ');
            document.getElementById('statRings').textContent = currentData.divisors.length;
            document.getElementById('statPoints').textContent = currentData.allPoints.length;
            document.getElementById('statPhi').textContent = currentData.phi;
            document.getElementById('statChannels').textContent = currentData.divisors.length - 1;
            
            // Ring info
            let ringInfo = '';
            if (currentData.isPrime) {
                ringInfo = '<strong>PRIME MODULUS (Fermat\'s Little Theorem):</strong><br><br>';
                ringInfo += `For prime p=${M}:<br>`;
                ringInfo += `• All ${M-1} non-zero residues are coprime<br>`;
                ringInfo += `• gcd(r,${M}) = 1 for all r∈{1,2,...,${M-1}}<br>`;
                ringInfo += `• Only r=0 reduces: 0/${M} → 0/1<br>`;
                ringInfo += `• Single Farey channel to M'=1<br><br>`;
                ringInfo += `<strong>This visualizes:</strong> a^${M-1} ≡ 1 (mod ${M})`;
            } else {
                ringInfo = '<strong>COMPOSITE MODULUS (Farey Channels):</strong><br><br>';
                ringInfo += '<strong>Ring Structure:</strong><br>';
                currentData.divisors.slice().reverse().forEach(m => {
                    const ring = currentData.rings.get(m);
                    const coprime = ring.filter(pt => pt.isIrreducible && pt.r !== 0).length;
                    const reducible = ring.filter(pt => !pt.isIrreducible && pt.r !== 0).length;
                    ringInfo += `M=${m}: ${m} points, φ=${eulerPhi(m)} coprime`;
                    if (reducible > 0) ringInfo += `, ${reducible} reducible`;
                    ringInfo += `<br>`;
                });
            }
            document.getElementById('ringInfo').innerHTML = ringInfo;
            
            drawVisualization();
        }
        
        function setModulus(M) {
            document.getElementById('modulusInput').value = M;
            updateVisualization();
        }
        
        function exportPNG(resolution) {
            const sizes = { 
                'standard': [1920, 1080], 
                '2K': [2560, 1440], 
                '4K': [3840, 2160], 
                '8K': [7680, 4320] 
            };
            const [width, height] = sizes[resolution];
            
            const showLegend = document.getElementById('exportShowLegend').checked;
            const showStats = document.getElementById('exportShowStats').checked;
            const showFactorization = document.getElementById('exportShowFactorization').checked;
            const showDivisors = document.getElementById('exportShowDivisors').checked;
            const showRingInfo = document.getElementById('exportShowRingInfo').checked;
            const showColorKey = document.getElementById('exportShowColorKey').checked;
            const showSettings = document.getElementById('exportShowSettings').checked;
            const showTimestamp = document.getElementById('exportShowTimestamp').checked;
            
            const title = document.getElementById('exportTitle').value || 'Modular Rings & Farey Hierarchy';
            const subtitle = document.getElementById('exportSubtitle').value;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill black background
            tempCtx.fillStyle = '#000000';
            tempCtx.fillRect(0, 0, width, height);
            
            // Calculate layout dimensions - FIXED title height
            const titleHeight = height * 0.10; // 10% for title area
            const legendWidth = showLegend ? width * 0.22 : 0; // 22% for legend if enabled
            const mainWidth = width - legendWidth;
            const mainHeight = height - titleHeight;
            
            // === TITLE SECTION - FIXED positioning ===
            tempCtx.fillStyle = '#0a0a0a';
            tempCtx.fillRect(0, 0, width, titleHeight);
            
            // Border under title
            tempCtx.strokeStyle = '#333333';
            tempCtx.lineWidth = 3;
            tempCtx.beginPath();
            tempCtx.moveTo(0, titleHeight);
            tempCtx.lineTo(width, titleHeight);
            tempCtx.stroke();
            
            tempCtx.fillStyle = 'white';
            tempCtx.font = `bold ${Math.floor(height * 0.028)}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.fillText(title, width / 2, titleHeight * 0.32);
            
            // Subtitle with M info
            const status = currentData.isPrime ? 'PRIME' : 'COMPOSITE';
            const mainSubtitle = subtitle || `M = ${currentData.M} (${status}) | ${currentData.factorization}`;
            tempCtx.font = `${Math.floor(height * 0.018)}px Arial`;
            tempCtx.fillStyle = '#cccccc';
            tempCtx.fillText(mainSubtitle, width / 2, titleHeight * 0.58);
            
            if (showTimestamp) {
                tempCtx.font = `${Math.floor(height * 0.013)}px Arial`;
                tempCtx.fillStyle = '#888888';
                tempCtx.fillText(`Generated: ${new Date().toLocaleString()}`, width / 2, titleHeight * 0.85);
            }
            
            // === MAIN VISUALIZATION ===
            const vizSize = Math.min(mainWidth, mainHeight) * 0.92;
            const vizX = (mainWidth - vizSize) / 2;
            const vizY = titleHeight + (mainHeight - vizSize) / 2;
            
            const scale = vizSize / canvas.width;
            tempCtx.save();
            tempCtx.translate(vizX, vizY);
            tempCtx.scale(scale, scale);
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.restore();
            
            // === LEGEND PANEL ===
            if (showLegend) {
                const legendX = mainWidth;
                const legendY = titleHeight;
                const legendH = mainHeight;
                const legendPadding = width * 0.012;
                const lineHeight = height * 0.022;
                
                // Legend background
                tempCtx.fillStyle = '#0f0f0f';
                tempCtx.fillRect(legendX, legendY, legendWidth, legendH);
                
                // Border
                tempCtx.strokeStyle = '#444444';
                tempCtx.lineWidth = 2;
                tempCtx.strokeRect(legendX, legendY, legendWidth, legendH);
                
                let currentY = legendY + legendPadding * 2.5;
                
                // Helper to draw section
                function drawLegendSection(sectionTitle, content, spacing = lineHeight) {
                    tempCtx.fillStyle = '#00ffff';
                    tempCtx.font = `bold ${Math.floor(height * 0.016)}px Arial`;
                    tempCtx.textAlign = 'left';
                    tempCtx.fillText(sectionTitle, legendX + legendPadding, currentY);
                    currentY += spacing * 1.1;
                    
                    tempCtx.fillStyle = '#dddddd';
                    tempCtx.font = `${Math.floor(height * 0.013)}px Arial`;
                    
                    content.forEach(line => {
                        const maxWidth = legendWidth - legendPadding * 2.5;
                        const words = line.split(' ');
                        let currentLine = '';
                        
                        words.forEach(word => {
                            const testLine = currentLine + word + ' ';
                            const metrics = tempCtx.measureText(testLine);
                            if (metrics.width > maxWidth && currentLine !== '') {
                                tempCtx.fillText(currentLine.trim(), legendX + legendPadding * 1.5, currentY);
                                currentY += spacing * 0.9;
                                currentLine = word + ' ';
                            } else {
                                currentLine = testLine;
                            }
                        });
                        tempCtx.fillText(currentLine.trim(), legendX + legendPadding * 1.5, currentY);
                        currentY += spacing * 0.9;
                    });
                    currentY += spacing * 0.5;
                }
                
                // Stats
                if (showStats) {
                    drawLegendSection('STATISTICS', [
                        `Modulus: M = ${currentData.M}`,
                        `Type: ${status}`,
                        `φ(M) = ${currentData.phi}`,
                        `Reducible: ${currentData.M - currentData.phi}`,
                        `Ratio: ${((currentData.M - currentData.phi) / currentData.M * 100).toFixed(1)}%`,
                        `Rings: ${currentData.divisors.length}`,
                        `Points: ${currentData.allPoints.length}`
                    ]);
                }
                
                // Factorization
                if (showFactorization) {
                    drawLegendSection('FACTORIZATION', [
                        currentData.factorization
                    ]);
                }
                
                // Divisors
                if (showDivisors && currentData.divisors.length <= 30) {
                    const divList = currentData.divisors.join(', ');
                    drawLegendSection('DIVISORS', [divList]);
                }
                
                // Ring Info
                if (showRingInfo) {
                    const ringLines = [];
                    const displayDivisors = currentData.divisors.slice().reverse().slice(0, 6);
                    displayDivisors.forEach(m => {
                        const phi = eulerPhi(m);
                        ringLines.push(`M=${m}: φ=${phi}`);
                    });
                    if (currentData.divisors.length > 6) {
                        ringLines.push(`... +${currentData.divisors.length - 6} more`);
                    }
                    drawLegendSection('RINGS', ringLines);
                }
                
                // Color Key
                if (showColorKey) {
                    tempCtx.fillStyle = '#00ffff';
                    tempCtx.font = `bold ${Math.floor(height * 0.016)}px Arial`;
                    tempCtx.fillText('COLOR KEY', legendX + legendPadding, currentY);
                    currentY += lineHeight * 1.2;
                    
                    const colors = [
                        { color: '#ffd700', label: 'Farey Lines' },
                        { color: '#00ffff', label: 'Coprime (gcd=1)' },
                        { color: '#ff0066', label: 'Reducible (gcd>1)' },
                        { color: '#ffff00', label: 'r=0 position' }
                    ];
                    
                    colors.forEach(item => {
                        const dotSize = height * 0.01;
                        tempCtx.fillStyle = item.color;
                        tempCtx.beginPath();
                        tempCtx.arc(legendX + legendPadding * 1.8, currentY - dotSize * 0.3, dotSize, 0, 2 * Math.PI);
                        tempCtx.fill();
                        
                        tempCtx.fillStyle = '#dddddd';
                        tempCtx.font = `${Math.floor(height * 0.013)}px Arial`;
                        tempCtx.fillText(item.label, legendX + legendPadding * 4, currentY);
                        currentY += lineHeight * 1.0;
                    });
                    currentY += lineHeight * 0.4;
                }
                
                // Settings
                if (showSettings) {
                    const settingsLines = [
                        `Rotation: ${document.getElementById('rotation').value}°`,
                        `Differential: ${document.getElementById('ringRotation').value}°`,
                        `Point Size: ${document.getElementById('pointSize').value}`,
                        `Spacing: ${(parseFloat(document.getElementById('ringSpacing').value)/100).toFixed(1)}`
                    ];
                    drawLegendSection('SETTINGS', settingsLines);
                }
            }
            
            const link = document.createElement('a');
            link.download = `farey_M${currentData.M}_${resolution}_${Date.now()}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        }
        
        function exportCSV() {
            let csv = 'Ring_M,Residue_r,Theta_radians,Theta_degrees,GCD,Reduced_num,Reduced_denom,Status\n';
            currentData.allPoints.forEach(pt => {
                const deg = (pt.theta * 180 / Math.PI).toFixed(2);
                csv += `${pt.M},${pt.r},${pt.theta.toFixed(6)},${deg},${pt.d},${pt.rRed},${pt.mRed},${pt.isIrreducible ? 'Coprime' : 'Reducible'}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `farey_hierarchy_M${currentData.M}_${Date.now()}.csv`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // Event listeners
        document.getElementById('modulusSlider').addEventListener('input', (e) => {
            document.getElementById('modulusValue').textContent = e.target.value;
            document.getElementById('modulusInput').value = e.target.value;
        });
        
        document.getElementById('modulusInput').addEventListener('change', updateVisualization);
        document.getElementById('colorScheme').addEventListener('change', drawVisualization);
        document.getElementById('viewMode').addEventListener('change', (e) => {
            const is3D = e.target.value === '3d';
            document.getElementById('view3DControls').style.display = is3D ? 'block' : 'none';
            drawVisualization();
        });
        document.getElementById('showFareyLines').addEventListener('change', drawVisualization);
        document.getElementById('showZeroConnections').addEventListener('change', drawVisualization);
        document.getElementById('showCoprimes').addEventListener('change', drawVisualization);
        document.getElementById('showReducibles').addEventListener('change', drawVisualization);
        document.getElementById('showLabels').addEventListener('change', drawVisualization);
        document.getElementById('showAllRings').addEventListener('change', drawVisualization);
        document.getElementById('labelMode').addEventListener('change', drawVisualization);
        document.getElementById('labelFilter').addEventListener('change', drawVisualization);
        document.getElementById('coprimeColor').addEventListener('change', drawVisualization);
        
        // Slider event listeners with input box sync
        const sliderConfigs = {
            'pointSize': { scale: 1, suffix: '', decimals: 0, inputScale: 1 },
            'fareyLineWidth': { scale: 10, suffix: '', decimals: 1, inputScale: 0.1 },
            'fareyOpacity': { scale: 100, suffix: '', decimals: 2, inputScale: 0.01 },
            'ringSpacing': { scale: 100, suffix: '', decimals: 1, inputScale: 0.01 },
            'rotation': { scale: 1, suffix: '°', decimals: 0, inputScale: 1 },
            'ringRotation': { scale: 1, suffix: '°', decimals: 0, inputScale: 1 },
            'animSpeed': { scale: 100, suffix: 'x', decimals: 1, inputScale: 0.01 },
            'cameraDist': { scale: 10, suffix: '', decimals: 1, inputScale: 0.1 },
            'vertSpacing': { scale: 100, suffix: '', decimals: 1, inputScale: 0.01 },
            'rotX': { scale: 1, suffix: '°', decimals: 0, inputScale: 1 },
            'rotY': { scale: 1, suffix: '°', decimals: 0, inputScale: 1 },
            'rotZ': { scale: 1, suffix: '°', decimals: 0, inputScale: 1 },
            'perspective': { scale: 1, suffix: '', decimals: 0, inputScale: 1 }
        };
        
        Object.keys(sliderConfigs).forEach(id => {
            const config = sliderConfigs[id];
            const slider = document.getElementById(id);
            const input = document.getElementById(id + 'Input');
            const valueDisplay = document.getElementById(id + 'Value');
            
            if (!slider || !valueDisplay) return;
            
            // Slider changes update input and display
            slider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const displayValue = sliderValue / config.scale;
                valueDisplay.textContent = displayValue.toFixed(config.decimals) + config.suffix;
                
                // Update camera state for 3D controls
                if (id === 'cameraDist') camera.distance = displayValue;
                else if (id === 'rotX') camera.rotX = displayValue;
                else if (id === 'rotY') camera.rotY = displayValue;
                else if (id === 'rotZ') camera.rotZ = displayValue;
                else if (id === 'perspective') camera.perspective = displayValue;
                
                if (input) {
                    input.value = displayValue.toFixed(config.decimals);
                }
                drawVisualization();
            });
            
            // Input box changes update slider and display
            if (input) {
                input.addEventListener('input', (e) => {
                    let inputValue = parseFloat(e.target.value);
                    if (isNaN(inputValue)) return;
                    
                    // Clamp to min/max
                    const min = parseFloat(input.min);
                    const max = parseFloat(input.max);
                    inputValue = Math.max(min, Math.min(max, inputValue));
                    
                    // Update camera state for 3D controls
                    if (id === 'cameraDist') camera.distance = inputValue;
                    else if (id === 'rotX') camera.rotX = inputValue;
                    else if (id === 'rotY') camera.rotY = inputValue;
                    else if (id === 'rotZ') camera.rotZ = inputValue;
                    else if (id === 'perspective') camera.perspective = inputValue;
                    
                    // Update slider (convert back to slider scale)
                    const sliderValue = inputValue * config.scale;
                    slider.value = sliderValue;
                    
                    // Update display
                    valueDisplay.textContent = inputValue.toFixed(config.decimals) + config.suffix;
                    
                    drawVisualization();
                });
            }
        });
        
        document.getElementById('animateRotation').addEventListener('change', (e) => {
            if (e.target.checked) {
                const animate = () => {
                    if (!document.getElementById('animateRotation').checked) return;
                    const speed = parseFloat(document.getElementById('animSpeed').value) / 100;
                    const rot = (parseFloat(document.getElementById('rotation').value) + (0.5 * speed)) % 360;
                    document.getElementById('rotation').value = rot;
                    document.getElementById('rotationValue').textContent = rot.toFixed(0) + '°';
                    drawVisualization();
                    animationFrame = requestAnimationFrame(animate);
                };
                animate();
            } else if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        });
        
        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            if (!currentData) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.42;
            const globalRotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            const ringRotation = parseFloat(document.getElementById('ringRotation').value) * Math.PI / 180;
            const spacing = parseFloat(document.getElementById('ringSpacing').value) / 100;
            
            const divisors = currentData.divisors.slice().reverse();
            const radiusMap = new Map();
            const ringIndexMap = new Map();
            
            divisors.forEach((m, idx) => {
                radiusMap.set(m, baseRadius * Math.pow(0.85, idx * spacing));
                ringIndexMap.set(m, divisors.length - 1 - idx);
            });
            
            function getAngle(r, m) {
                const ringIndex = ringIndexMap.get(m);
                return (2 * Math.PI * r) / m + globalRotation + (ringRotation * ringIndex);
            }
            
            let hoveredPoint = null;
            let minDist = Infinity;
            
            currentData.allPoints.forEach(pt => {
                const radius = radiusMap.get(pt.M);
                const angle = getAngle(pt.r, pt.M);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                
                if (dist < minDist && dist < 12) {
                    minDist = dist;
                    hoveredPoint = pt;
                }
            });
            
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
                
                const deg = (hoveredPoint.theta * 180 / Math.PI).toFixed(1);
                tooltip.innerHTML = `
                    <strong>Ring M=${hoveredPoint.M}, r=${hoveredPoint.r}</strong><br>
                    θ = 2π(${hoveredPoint.r})/${hoveredPoint.M} = ${deg}°<br>
                    gcd(${hoveredPoint.r}, ${hoveredPoint.M}) = ${hoveredPoint.d}<br>
                    ${hoveredPoint.r !== 0 ? `${hoveredPoint.r}/${hoveredPoint.M} → ${hoveredPoint.rRed}/${hoveredPoint.mRed}` : 'r=0 (at θ=0, 3 o\'clock)'}
                `;
            } else {
                tooltip.style.display = 'none';
            }
        });
        
        canvas.addEventListener('click', (e) => {
            if (!currentData) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = Math.min(canvas.width, canvas.height) * 0.42;
            const globalRotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            const ringRotation = parseFloat(document.getElementById('ringRotation').value) * Math.PI / 180;
            const spacing = parseFloat(document.getElementById('ringSpacing').value) / 100;
            
            const divisors = currentData.divisors.slice().reverse();
            const radiusMap = new Map();
            const ringIndexMap = new Map();
            
            divisors.forEach((m, idx) => {
                radiusMap.set(m, baseRadius * Math.pow(0.85, idx * spacing));
                ringIndexMap.set(m, divisors.length - 1 - idx);
            });
            
            function getAngle(r, m) {
                const ringIndex = ringIndexMap.get(m);
                return (2 * Math.PI * r) / m + globalRotation + (ringRotation * ringIndex);
            }
            
            let clickedPoint = null;
            let minDist = Infinity;
            
            currentData.allPoints.forEach(pt => {
                const radius = radiusMap.get(pt.M);
                const angle = getAngle(pt.r, pt.M);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                
                if (dist < minDist && dist < 12) {
                    minDist = dist;
                    clickedPoint = pt;
                }
            });
            
            if (clickedPoint) {
                let info = `<strong>Point: r=${clickedPoint.r} on Ring M=${clickedPoint.M}</strong><br><br>`;
                info += `Angle: θ = 2π(${clickedPoint.r})/${clickedPoint.M}<br>`;
                info += `gcd(${clickedPoint.r}, ${clickedPoint.M}) = ${clickedPoint.d}<br><br>`;
                
                if (clickedPoint.r === 0) {
                    info += `<strong>r=0 special case:</strong><br>`;
                    info += `Always at θ=0 (3 o'clock)<br>`;
                    info += `gcd(0, M) = M for any M<br>`;
                    info += `Only reducible residue for primes`;
                } else if (clickedPoint.M === clickedPoint.mRed && currentData.isPrime) {
                    info += `<strong>Prime Modulus - Coprime Residue</strong><br>`;
                    info += `This is one of ${currentData.phi} coprime residues<br>`;
                    info += `For prime p: gcd(r,p)=1 for all r≠0<br>`;
                    info += `<strong>Fermat's Little Theorem:</strong><br>`;
                    info += `${clickedPoint.r}^${currentData.M-1} ≡ 1 (mod ${currentData.M})`;
                } else if (clickedPoint.mRed < clickedPoint.M) {
                    info += `<strong>Reduction Path:</strong><br>`;
                    info += `${clickedPoint.r}/${clickedPoint.M} → ${clickedPoint.rRed}/${clickedPoint.mRed}<br>`;
                    info += `Dividing by gcd = ${clickedPoint.d}<br>`;
                    info += `Projects to ring M'=${clickedPoint.mRed}`;
                } else {
                    info += `<strong>Already in lowest terms</strong><br>`;
                    info += `This is a coprime residue (φ class)`;
                }
                
                document.getElementById('clickInfo').innerHTML = info;
            }
        });
        
        // Initialize
        updateVisualization();
        
        // Mouse interaction for 3D mode
        canvas.addEventListener('mousedown', (e) => {
            if (document.getElementById('viewMode').value !== '3d') return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || document.getElementById('viewMode').value !== '3d') return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            camera.rotY += deltaX * 0.5;
            camera.rotX -= deltaY * 0.5;
            
            camera.rotX = Math.max(-90, Math.min(90, camera.rotX));
            camera.rotY = camera.rotY % 360;
            
            document.getElementById('rotX').value = camera.rotX;
            document.getElementById('rotY').value = camera.rotY;
            document.getElementById('rotXInput').value = camera.rotX;
            document.getElementById('rotYInput').value = camera.rotY;
            document.getElementById('rotXValue').textContent = camera.rotX.toFixed(0) + '°';
            document.getElementById('rotYValue').textContent = camera.rotY.toFixed(0) + '°';
            
            drawVisualization();
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            if (document.getElementById('viewMode').value === '3d') {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'crosshair';
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            if (document.getElementById('viewMode').value !== '3d') return;
            e.preventDefault();
            
            camera.distance += e.deltaY * 0.001;
            camera.distance = Math.max(2, Math.min(8, camera.distance));
            
            document.getElementById('cameraDist').value = camera.distance * 10;
            document.getElementById('cameraDistInput').value = camera.distance.toFixed(1);
            document.getElementById('cameraDistValue').textContent = camera.distance.toFixed(1);
            
            drawVisualization();
        }, { passive: false });
    </script>
</body>
    </html>
